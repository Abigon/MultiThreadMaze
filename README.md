# MultiThreadMaze


## Алгоритм Краскала: 
это алгоритм, создающий минимальное связующее дерево. 
Это интересно, потому что он не «выращивает» лабиринт подобно дереву, а скорее вырезает сегменты проходов 
по всему лабиринту случайным образом, и тем не менее в результате создаёт в конце идеальный лабиринт. 
Для его работы требуется объём памяти, пропорциональный размеру лабиринта, а также возможность перечисления 
каждого ребра или стены между ячейками лабиринта в случайном порядке (обычно для этого создаётся список всех 
рёбер и перемешивается случайным образом). Помечаем каждую ячейку уникальным идентификатором, а затем 
обходим все рёбра в случайном порядке. Если ячейки с обеих сторон от каждого ребра имеют разные идентификаторы, 
то удаляем стену и задаём всем ячейкам с одной стороны тот же идентификатор, что и ячейкам с другой.
Если ячейки на обеих сторонах стены уже имеют одинаковый идентификатор, то между ними уже существует какой-то 
путь, поэтому стену можно оставить, чтобы не создавать петель. Этот алгоритм создаёт лабиринты с низким 
показателем текучести, но не таким низким, как у алгоритма Прима. Объединение двух множество по обеим сторонам 
стены будет медленной операцией, если у каждой ячейки есть только номер и они объединяются в цикле. Объединение, 
а также поиск можно выполнять почти за постоянное время благодаря использованию алгоритма объединения-поиска 
(union-find algorithm): помещаем каждую ячейку в древовидную структуру, корневым элементом является 
идентификатор. Объединение выполняется быстро благодаря сращиванию двух деревьев. При правильной реализации 
этот алгоритм работает достаточно быстро, но медленнее большинства из-за создания списка рёбер и управления
https://temofeev.ru/info/articles/labirinty-klassifikatsiya-generirovanie-poisk-resheniy/