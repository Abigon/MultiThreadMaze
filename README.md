# MultiThreadMaze


## Создайте генерацию лабиринтов на потоках (хард):

- сделайте так, чтобы отдельный поток создал свою секцию лабиринта;
- убедитесь, что лабиринт имеет решение;
- проследите, что есть возможность масштабирования и лёгкие настройки сложности лабиринта;
- ОПЦИОНАЛЬНО — сделайте несколько связных лабиринтов на отдельных потоках;
- решите проблему точек входа и выхода из разных секций лабиринта.

Примечание:
- Про лабиринты и их алгоритмы.
- Используйте bool-параметр, чтобы продемонстрировать работу своего алгоритма с задержками Sleep на 0.5f секунд для создания каждой секции стены.
- Ваша задача в многопоточном режиме — добится быстрого результата несмотря на задержку sleep.


## Алгоритм Краскала: 
это алгоритм, создающий минимальное связующее дерево. 
Это интересно, потому что он не «выращивает» лабиринт подобно дереву, а скорее вырезает сегменты проходов 
по всему лабиринту случайным образом, и тем не менее в результате создаёт в конце идеальный лабиринт. 
Для его работы требуется объём памяти, пропорциональный размеру лабиринта, а также возможность перечисления 
каждого ребра или стены между ячейками лабиринта в случайном порядке (обычно для этого создаётся список всех 
рёбер и перемешивается случайным образом). Помечаем каждую ячейку уникальным идентификатором, а затем 
обходим все рёбра в случайном порядке. Если ячейки с обеих сторон от каждого ребра имеют разные идентификаторы, 
то удаляем стену и задаём всем ячейкам с одной стороны тот же идентификатор, что и ячейкам с другой.
Если ячейки на обеих сторонах стены уже имеют одинаковый идентификатор, то между ними уже существует какой-то 
путь, поэтому стену можно оставить, чтобы не создавать петель. Этот алгоритм создаёт лабиринты с низким 
показателем текучести

https://temofeev.ru/info/articles/labirinty-klassifikatsiya-generirovanie-poisk-resheniy/